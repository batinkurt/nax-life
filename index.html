<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NAX.LIFE: Run with RÃ¼zgar</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #110022;
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --glitch-green: #00ff41;
            --ui-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'VT323', monospace;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            image-rendering: pixelated;
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.15);
            background-color: #000;
        }

        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            z-index: 10;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 20;
        }

        .hud { display: none; }

        /* Music Button (Top Right - In Game) */
        .music-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            min-width: 80px;
            height: 40px;
            padding: 0 10px;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 0 10px var(--neon-blue);
            text-transform: uppercase;
            transition: all 0.2s;
        }
        .music-btn:hover { background: var(--neon-blue); color: #000; }
        .music-btn.off { border-color: #555; color: #555; box-shadow: none; }
        .music-btn.hidden-btn { display: none; } /* Hide via class if needed */

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--ui-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            pointer-events: auto;
            text-align: center;
            color: white;
            transition: opacity 0.5s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 5rem;
            margin: 0;
            color: var(--neon-pink);
            text-shadow: 4px 4px 0px var(--neon-blue);
            animation: glitch-text 3s infinite;
            line-height: 0.9;
        }

        h2 {
            font-size: 2rem;
            color: var(--neon-blue);
            margin-bottom: 3rem;
            letter-spacing: 4px;
        }

        .arrow-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            font-family: 'VT323', monospace;
            font-size: 2rem;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 0 10px var(--neon-blue);
        }
        .arrow-btn:hover { 
            background: var(--neon-blue); 
            color: #000; 
            transform: scale(1.1);
        }

        .btn {
            background: transparent;
            border: 2px solid var(--glitch-green);
            color: var(--glitch-green);
            font-family: 'VT323', monospace;
            font-size: 2rem;
            padding: 15px 40px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px var(--glitch-green);
            transition: all 0.2s;
            margin-top: 20px;
            width: 250px; 
        }

        .btn:hover {
            background: var(--glitch-green);
            color: #000;
            transform: scale(1.05);
        }
        
        .btn-secondary {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
        }
        .btn-secondary:hover { background: var(--neon-blue); }

        .btn-group { display: flex; gap: 20px; margin-top: 20px; }
        .btn-group-vertical { display: flex; flex-direction: column; gap: 20px; margin-top: 40px; }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            text-align: left;
            margin: 20px 0;
            font-size: 1.5rem;
            background: rgba(255,255,255,0.05);
            padding: 30px;
            border: 1px solid var(--neon-blue);
            border-radius: 8px;
        }

        .story-text {
            font-size: 2rem;
            line-height: 1.4;
            color: white;
            max-width: 800px;
            white-space: pre-wrap;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .skip-hint {
            margin-top: 40px; 
            font-size: 16px; 
            color: #888; 
            animation: blink 2s infinite;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
        }

        .toast {
            position: absolute;
            bottom: 50px;
            background: #fff;
            color: #000;
            padding: 10px 20px;
            font-size: 1.2rem;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 100;
        }
        .toast.show { opacity: 1; }

        @keyframes glitch-text {
            0% { transform: skew(0deg); } 20% { transform: skew(-2deg); } 21% { transform: skew(2deg); } 22% { transform: skew(0deg); } 100% { transform: skew(0deg); }
        }
        @keyframes blink { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="crt-overlay"></div>
    
    <button class="music-btn hidden-btn" id="musicBtn" onclick="toggleMusic()">RETRO</button>

    <!-- MAIN MENU -->
    <div id="mainMenu" class="screen">
        <h1>NAX.LIFE</h1>
        <h2>RUN WITH RÃœZGAR</h2>
        
        <div class="btn-group-vertical">
            <button class="btn" onclick="startStory()">PLAY GAME</button>
            <button class="btn btn-secondary" onclick="showCustomization()">WEAR OUTFITS</button>
            <button class="btn btn-secondary" id="menuMusicBtn" onclick="toggleMusic()">MUSIC: RETRO</button>
        </div>
    </div>

    <!-- CUSTOMIZATION SCREEN -->
    <div id="customizationScreen" class="screen hidden">
        <h2 style="margin-bottom: 0;">SELECT GEAR</h2>
        
        <div style="position: relative; width: 600px; height: 300px; margin: 20px 0;">
            <div style="position: absolute; left: 0; top: 100px; width: 100%; display: flex; justify-content: space-between; align-items: center; z-index: 50;">
                <button class="arrow-btn" onclick="changeChar('nax', -1)">â—„</button>
                <div style="width: 100px;"></div> <button class="arrow-btn" onclick="changeChar('nax', 1)">â–º</button>
            </div>
            <div style="position: absolute; left: 0; top: 220px; width: 100%; display: flex; justify-content: space-between; align-items: center; z-index: 50;">
                <button class="arrow-btn" onclick="changeChar('ruzgar', -1)">â—„</button>
                <div style="width: 100px;"></div> <button class="arrow-btn" onclick="changeChar('ruzgar', 1)">â–º</button>
            </div>
            <div style="position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-around; color: var(--neon-blue); font-size: 1.5rem; text-shadow: 0 0 10px var(--neon-blue);">
                <span id="naxName">PANDA NAX</span>
            </div>
             <div style="position: absolute; bottom: -40px; width: 100%; display: flex; justify-content: space-around; color: var(--neon-blue); font-size: 1.5rem; text-shadow: 0 0 10px var(--neon-blue);">
                <span id="ruzgarName">TERRIER</span>
            </div>
        </div>

        <div class="btn-group">
            <button class="btn btn-secondary" onclick="showMainMenu()">BACK</button>
            <button class="btn" onclick="startStory()">READY TO RUN</button>
        </div>
    </div>

    <div id="storyScreen" class="screen hidden" onclick="skipIntro()">
        <div class="story-text" id="storyText"></div>
        <div class="skip-hint">Tap to Skip</div>
    </div>

    <div id="gameOverScreen" class="screen hidden">
        <h1 style="color: #ff3333;">SIGNAL LOST</h1>
        <p class="story-text" style="font-size: 1.5rem;">But RÃ¼zgar stayed.</p>
        
        <div class="stats-grid">
            <div style="color: #00f3ff;">TUNES:</div> <div id="endHeadphones">0</div>
            <div style="color: #ffccaa;">BONES:</div> <div id="endFood">0</div>
            <div style="color: #ff0044;">LIVES:</div> <div id="endPills">0</div>
            <div style="color: #fff;">DISTANCE:</div> <div id="finalScore">0</div>
        </div>

        <div class="btn-group">
            <button class="btn btn-secondary" onclick="shareStats()">SHARE RUN</button>
            <button class="btn" onclick="resetGame()">MAIN MENU</button>
        </div>
    </div>

    <div id="toast" class="toast">Stats copied to clipboard!</div>
</div>

<script>
/**
 * NAX.LIFE: RUN WITH RÃœZGAR
 * Version 7.2: Fixed HUD Overlap
 */

// --- CONFIGURATION ---
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 450;
const GRAVITY = 1.2;     
const JUMP_FORCE = -16;  
const GROUND_Y = 380;
const SPRITE_SCALE = 3;

// --- ASSETS ---

const NAX_VARIANTS = [
    { name: "PANDA NAX", colors: { hat: '#fff', hair: '#6b4226', skin: '#ffccaa', clothes: '#ff00ff', boots: '#00f3ff' } },
    { name: "SAKURA NAX", colors: { hat: '#ffb7c5', hair: '#f4d03f', skin: '#ffe0bd', clothes: '#ff69b4', boots: '#fff' } },
    { name: "CYBER NAX", colors: { hat: '#333', hair: '#ff0055', skin: '#e0e0e0', clothes: '#00f3ff', boots: '#ffff00' } }
];

const NAX_BASE_MATRIX = {
    idle: [
        ['T','T','E','E','T','T','T','T','E','E','T','T'],
        ['T','E','H','H','E','T','T','E','H','H','E','T'],
        ['E','H','H','H','H','H','H','H','H','H','H','E'],
        ['E','H','E','E','H','H','H','H','E','E','H','E'],
        ['E','H','H','H','H','H','H','H','H','H','H','E'],
        ['A','E','A','A','S','S','S','S','A','A','E','A'],
        ['A','A','S','E','S','S','S','S','E','S','A','A'],
        ['A','A','S','S','S','C','C','S','S','S','A','A'],
        ['T','A','C','C','C','C','C','C','C','C','A','T'],
        ['T','C','B','B','C','C','C','C','B','B','C','T'],
        ['T','B','T','T','C','C','C','C','T','T','B','T'], 
        ['T','T','T','E','E','T','T','E','E','T','T','T'],
        ['T','T','T','E','E','T','T','E','E','T','T','T'],
        ['T','T','T','B','B','T','T','B','B','T','T','T']
    ],
    run: [
        ['T','T','E','E','T','T','T','T','E','E','T','T'],
        ['T','E','H','H','E','T','T','E','H','H','E','T'],
        ['E','H','H','H','H','H','H','H','H','H','H','E'],
        ['E','H','E','E','H','H','H','H','E','E','H','E'],
        ['E','H','H','H','H','H','H','H','H','H','H','E'],
        ['A','E','A','A','S','S','S','S','A','A','E','A'],
        ['A','T','S','E','S','S','S','S','E','S','T','A'],
        ['A','A','S','S','S','C','C','S','S','S','A','A'], 
        ['A','A','C','C','C','C','C','C','C','C','A','A'],
        ['T','T','B','B','C','C','C','C','B','B','T','T'],
        ['T','B','T','T','C','C','C','C','T','T','B','T'], 
        ['T','T','T','E','E','T','T','T','T','T','T','T'],
        ['T','T','T','E','E','T','T','E','E','T','T','T'],
        ['T','T','B','B','T','T','T','B','B','T','T','T']
    ],
    crouch: [
        ['T','T','T','T','T','T','T','T','T','T','T','T'], 
        ['T','T','T','T','T','T','T','T','T','T','T','T'],
        ['T','T','T','T','T','T','T','T','T','T','T','T'],
        ['T','T','E','E','T','T','T','T','E','E','T','T'], 
        ['T','E','H','H','E','T','T','E','H','H','E','T'],
        ['E','H','H','H','H','H','H','H','H','H','H','E'], 
        ['E','H','E','E','H','H','H','H','E','E','H','E'], 
        ['E','H','H','H','H','H','H','H','H','H','H','E'],
        ['A','E','A','A','S','S','S','S','A','A','E','A'],
        ['A','A','C','C','C','C','C','C','C','C','A','A'],
        ['T','C','B','B','C','C','C','C','B','B','C','T'],
        ['T','T','T','B','B','T','T','B','B','T','T','T'],
        ['T','T','T','B','B','T','T','B','B','T','T','T'],
        ['T','B','B','T','T','T','T','T','T','B','B','T']
    ]
};

const RUZGAR_VARIANTS = [
    { name: "TERRIER", colors: { base: '#fff', spot: '#000' } },
    { name: "COCOA", colors: { base: '#d2b48c', spot: '#8b4513' } },
    { name: "MOON", colors: { base: '#eee', spot: '#aaa' } }
];

const RUZGAR_BASE_MATRIX = {
    idle: [
        ['T','S','T','T','T','T','S','T','T','T'], 
        ['T','S','B','B','B','B','S','T','T','T'], 
        ['T','B','E','B','B','E','B','T','T','T'], 
        ['T','B','B','E','E','B','B','T','T','T'], 
        ['T','T','R','R','R','R','T','T','T','T'], 
        ['T','B','B','S','S','B','B','T','B','T'], 
        ['T','B','B','S','S','B','B','T','B','T'], 
        ['T','B','T','T','T','T','B','T','T','T'], 
        ['T','E','T','T','T','T','E','T','T','T']  
    ],
    run: [
        ['T','S','T','T','T','T','S','T','T','T'],
        ['T','S','B','B','B','B','S','T','T','T'],
        ['T','B','E','B','B','E','B','T','T','T'],
        ['T','B','B','E','E','B','B','T','T','T'],
        ['T','T','R','R','R','R','T','T','T','T'], 
        ['T','B','B','S','S','B','B','T','T','T'], 
        ['T','B','B','S','S','B','B','T','B','B'], 
        ['T','T','B','T','T','B','T','T','T','T'], 
        ['T','T','E','T','T','E','T','T','T','T'] 
    ]
};

// --- OBJECT SPRITES ---

const TOWER_SPRITE = [
    ['T','T','T','R','T','T','T'], ['T','T','G','G','G','T','T'],
    ['T','T','T','G','T','T','T'], ['T','T','G','G','G','T','T'],
    ['T','G','T','G','T','G','T'], ['T','G','T','G','T','G','T'],
    ['G','T','T','G','T','T','G'], ['G','T','T','G','T','T','G'],
    ['G','T','T','G','T','T','G']
];

const TREE_SPRITE = [
    ['T','T','T','G','G','T','T','T'],
    ['T','T','G','G','G','G','T','T'],
    ['T','G','G','G','G','G','G','T'],
    ['T','G','G','G','G','G','G','T'],
    ['T','T','G','G','G','G','T','T'],
    ['T','T','T','B','B','T','T','T'],
    ['T','T','T','B','B','T','T','T'],
    ['T','T','T','B','B','T','T','T']
];

const TV_SPRITE = [
    ['T','G','G','G','G','G','T'], ['G','C','C','C','C','C','G'],
    ['G','C','W','B','C','C','G'], ['G','C','B','B','B','C','G'],
    ['G','C','C','C','C','C','G'], ['G','G','G','G','G','G','G'],
    ['T','T','T','G','T','T','T'], ['T','T','G','G','G','T','T']
];

const DRONE_SPRITE = [
    ['T','T','G','G','G','T','T'], ['T','G','R','R','R','G','T'],
    ['G','R','W','W','W','R','G'], ['G','R','W','W','W','R','G'],
    ['T','G','R','R','R','G','T'], ['T','T','C','C','C','T','T'], ['T','C','T','C','T','C','T']
];

const HYDRANT_SPRITE = [
    ['T','T','T','R','R','T','T'], ['T','T','R','R','R','R','T'],
    ['T','R','R','R','R','R','R'], ['T','T','R','R','R','R','T'],
    ['T','T','R','W','W','R','T'], ['T','T','R','R','R','R','T'],
    ['T','R','R','R','R','R','R']
];

const SIGN_SPRITE = [
    ['G','G','G','G','G','G','G','G'],
    ['G','C','C','C','C','C','C','G'],
    ['G','C','T','E','C','H','C','G'],
    ['G','C','C','C','C','C','C','G'],
    ['G','G','G','G','G','G','G','G']
];

// --- HUD ICONS ---
const ICON_HEART = [
    ['T','R','R','T','R','R','T'],
    ['R','W','R','R','R','R','R'],
    ['R','R','R','R','R','R','R'],
    ['T','R','R','R','R','R','T'],
    ['T','T','R','R','R','T','T'],
    ['T','T','T','R','T','T','T']
];

const ICON_HEADPHONE = [
    ['T','T','T','G','G','G','T','T','T'],
    ['T','T','G','T','T','T','G','T','T'],
    ['T','G','T','T','T','T','T','G','T'],
    ['G','B','B','T','T','T','B','B','G'],
    ['G','C','B','T','T','T','B','C','G'],
    ['G','C','C','T','T','T','C','C','G'],
    ['T','C','C','T','T','T','C','C','T']
];

const ICON_BONE = [
    ['T','W','W','T','T','T','W','W','T'],
    ['W','W','W','W','W','W','W','W','W'],
    ['T','W','W','W','W','W','W','W','T'],
    ['T','W','W','T','T','T','W','W','T']
];

const ICON_PILL = [
    ['T','T','R','R','W','W','T','T'],
    ['T','R','R','R','W','W','W','T'],
    ['T','R','R','R','W','W','W','T'],
    ['T','T','R','R','W','W','T','T']
];

// --- ITEMS ---
const PILL_SPRITE = [
    ['T','T','T','T','T','T'], ['T','R','R','W','W','T'],
    ['T','R','R','W','W','T'], ['T','R','R','W','W','T'], ['T','T','T','T','T','T']
];

const HEADPHONE_SPRITE = [
    ['T','T','C','C','C','T','T'], ['T','C','T','T','T','C','T'],
    ['C','B','T','T','T','B','C'], ['C','B','B','T','B','B','C'],
    ['T','B','B','T','B','B','T'], ['T','T','T','T','T','T','T']
];

const BONE_ITEM_SPRITE = [
    ['T','T','E','E','T','T','E','E','T','T'],
    ['T','E','W','W','E','E','W','W','E','T'],
    ['T','E','W','W','W','W','W','W','E','T'],
    ['T','E','W','W','W','W','W','W','E','T'],
    ['T','E','W','W','E','E','W','W','E','T'],
    ['T','T','E','E','T','T','E','E','T','T']
];

// --- AUDIO SYSTEM ---
const Audio = {
    ctx: null,
    musicOn: true,
    oscList: [],
    
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    
    playTone: function(freq, type, duration, vol=0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    
    // SFX
    jump: function() { this.playTone(350, 'square', 0.1, 0.05); },
    slide: function() { this.playTone(150, 'sawtooth', 0.2, 0.03); },
    bark: function() { this.playTone(800, 'triangle', 0.05, 0.05); },
    collect: function() { this.playTone(1200, 'sine', 0.2); },
    lifeUp: function() { 
        this.playTone(600, 'sine', 0.1); 
        setTimeout(() => this.playTone(800, 'sine', 0.1), 100);
        setTimeout(() => this.playTone(1000, 'sine', 0.2), 200);
    },
    eat: function() { this.playTone(200, 'triangle', 0.1, 0.1); },
    hit: function() { 
        this.playTone(100, 'sawtooth', 0.3); 
        this.playTone(50, 'sawtooth', 0.3);
    },
    select: function() { this.playTone(600, 'square', 0.05, 0.05); }
};

// --- MUSIC SYSTEM ---
const Music = {
    trackIndex: 0, // 0: Retro, 1: DnB, 2: Off
    isPlaying: false,
    timer: null,
    beat: 0,
    
    tracks: [
        {
            name: "RETRO",
            speed: 150,
            loopLen: 8,
            bass: [130.81, 130.81, 130.81, 130.81, 155.56, 155.56, 174.61, 174.61], // C3
            lead: [523.25, 0, 523.25, 622.25, 783.99, 0, 622.25, 523.25],
            typeBass: 'sawtooth',
            typeLead: 'square'
        },
        {
            name: "DNB",
            speed: 90, // Faster
            loopLen: 16,
            bass: [55, 0, 0, 0, 55, 0, 0, 0, 43.65, 0, 0, 43.65, 0, 0, 49, 0], // Deep Sub
            lead: [880, 0, 0, 659, 0, 0, 523, 0, 0, 0, 659, 0, 783, 0, 523, 0], // Smooth keys
            typeBass: 'sine',
            typeLead: 'triangle'
        }
    ],

    start: function() {
        if(this.trackIndex >= this.tracks.length) return;
        this.isPlaying = true;
        this.beat = 0;
        if(this.timer) clearTimeout(this.timer);
        this.loop();
    },

    stop: function() {
        this.isPlaying = false;
        if(this.timer) clearTimeout(this.timer);
    },

    loop: function() {
        if(!this.isPlaying || this.trackIndex >= this.tracks.length) return;
        
        const track = this.tracks[this.trackIndex];
        const step = this.beat % track.loopLen;

        let bassFreq = track.bass[step % track.bass.length];
        if(bassFreq > 0) Audio.playTone(bassFreq, track.typeBass, 0.2, 0.15);

        let leadFreq = track.lead[step % track.lead.length];
        if(leadFreq > 0) Audio.playTone(leadFreq, track.typeLead, 0.1, 0.05);

        // Simple Drum simulation for DnB
        if(this.trackIndex === 1) {
            if(step === 0 || step === 10) Audio.playTone(100, 'square', 0.05, 0.1); 
            if(step === 4 || step === 12) Audio.playTone(200, 'sawtooth', 0.05, 0.05);
        }

        this.beat++;
        this.timer = setTimeout(() => this.loop(), track.speed);
    }
};

function toggleMusic() {
    Audio.init();
    Music.trackIndex = (Music.trackIndex + 1) % 3; 
    
    // Update both buttons
    const hudBtn = document.getElementById('musicBtn');
    const menuBtn = document.getElementById('menuMusicBtn');
    
    let label = "";
    let isOff = false;

    if (Music.trackIndex === 2) {
        // OFF
        Music.stop();
        label = "OFF";
        isOff = true;
        Audio.musicOn = false;
    } else {
        // PLAYING
        Music.stop(); 
        Audio.musicOn = true;
        label = Music.tracks[Music.trackIndex].name;
        Music.start();
    }

    if(hudBtn) {
        hudBtn.innerText = label;
        if(isOff) hudBtn.classList.add('off'); else hudBtn.classList.remove('off');
    }
    if(menuBtn) {
        menuBtn.innerText = "MUSIC: " + label;
    }
}

// --- GAME STATE ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let frames = 0;
let animationId;
let isRunning = false;
let gameSpeed = 8.0; 
let score = 0;
let hearts = 3;
let invulnerabilityTimer = 0; 
let currentZone = 'CITY'; // CITY or PARK
let zoneTimer = 0;

// Selection State
let currentNaxIndex = 0;
let currentRuzgarIndex = 0;
let isMenu = true;

// Entities
let player;
let ruzgar;
let obstacles = [];
let items = [];
let particles = [];
let spawnTimer = 0;
let damageShake = 0;

let stats = { headphones: 0, food: 0, pills: 0 };

function resize() {
    let scale = Math.min(window.innerWidth / CANVAS_WIDTH, window.innerHeight / CANVAS_HEIGHT);
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    canvas.style.width = (CANVAS_WIDTH * scale) + 'px';
    canvas.style.height = (CANVAS_HEIGHT * scale) + 'px';
    ctx.imageSmoothingEnabled = false; 
}
window.addEventListener('resize', resize);
resize();

// --- CUSTOMIZATION LOGIC ---
function changeChar(type, dir) {
    Audio.init();
    Audio.select();
    if(type === 'nax') {
        currentNaxIndex = (currentNaxIndex + dir + NAX_VARIANTS.length) % NAX_VARIANTS.length;
        document.getElementById('naxName').innerText = NAX_VARIANTS[currentNaxIndex].name;
    } else {
        currentRuzgarIndex = (currentRuzgarIndex + dir + RUZGAR_VARIANTS.length) % RUZGAR_VARIANTS.length;
        document.getElementById('ruzgarName').innerText = RUZGAR_VARIANTS[currentRuzgarIndex].name;
    }
    // Start music on interaction if enabled
    if(Audio.musicOn && !Music.isPlaying) Music.start();
}

function showCustomization() {
    Audio.init();
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('customizationScreen').classList.remove('hidden');
}

function showMainMenu() {
    Audio.init();
    document.getElementById('customizationScreen').classList.add('hidden');
    document.getElementById('mainMenu').classList.remove('hidden');
}

// --- RENDERING HELPERS ---
function drawNaxSprite(ctx, frameMatrix, x, y, scale, variant) {
    const pal = variant.colors;
    frameMatrix.forEach((row, rI) => {
        row.forEach((col, cI) => {
            if (col === 'T') return;
            let c = '#fff';
            if (col === 'H') c = pal.hat;
            if (col === 'S') c = pal.skin;
            if (col === 'C') c = pal.clothes;
            if (col === 'B') c = pal.boots;
            if (col === 'E') c = '#111'; 
            if (col === 'A') c = pal.hair; 
            ctx.fillStyle = c;
            ctx.fillRect(x + cI * scale, y + rI * scale, scale, scale);
        });
    });
}

function drawRuzgarSprite(ctx, frameMatrix, x, y, scale, variant) {
    const pal = variant.colors;
    frameMatrix.forEach((row, rI) => {
        row.forEach((col, cI) => {
            if (col === 'T') return;
            let c = '#fff';
            if (col === 'B') c = pal.base;
            if (col === 'S') c = pal.spot;
            if (col === 'E') c = '#111';
            if (col === 'R') c = '#ff0044';
            if (col === 'W') c = '#fff'; 
            ctx.fillStyle = c;
            ctx.fillRect(x + cI * scale, y + rI * scale, scale, scale);
        });
    });
}

function drawGeneralSprite(ctx, matrix, x, y, scale, type = null) {
    matrix.forEach((row, rI) => {
        row.forEach((col, cI) => {
            if (col !== 'T') {
                ctx.fillStyle = getObjectColor(col, type);
                ctx.fillRect(x + cI * scale, y + rI * scale, scale, scale);
            }
        });
    });
}

function getObjectColor(code, type) {
    if (type === 'TV' && code === 'C' && Math.random() > 0.9) return '#fff'; 
    if (type === 'DRONE' && code === 'R' && Math.random() > 0.8) return '#ffff00';
    if (type === 'TREE') {
         if (code === 'G') return '#2d6e32'; // Leaves
         if (code === 'B') return '#4a3c31'; // Trunk
    }
    switch(code) {
        case 'W': return '#ffffff';
        case 'B': return '#111111'; 
        case 'S': return '#ffccaa'; 
        case 'C': return '#00f3ff'; 
        case 'R': return '#ff0044'; 
        case 'G': return '#555555'; 
        case 'E': return '#000000'; // Black Edge
        default: return '#ff00ff';
    }
}

// --- CLASSES ---
class Entity {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.dy = 0;
        this.type = type; 
        this.grounded = false;
        this.frameTimer = 0;
        this.crouching = false;
        
        let baseMatrix = (type === 'nax') ? NAX_BASE_MATRIX.idle : RUZGAR_BASE_MATRIX.idle;
        this.baseH = baseMatrix.length * SPRITE_SCALE;
        this.w = baseMatrix[0].length * SPRITE_SCALE;
        this.h = this.baseH;
    }

    update() {
        this.y += this.dy;
        if (this.y + this.h < GROUND_Y) {
            this.dy += GRAVITY;
            this.grounded = false;
        } else {
            this.dy = 0;
            this.grounded = true;
            this.y = GROUND_Y - this.h;
        }

        if (this.crouching) {
            this.h = this.baseH * 0.6; 
            this.y = GROUND_Y - this.h; 
        } else {
            this.h = this.baseH;
        }
        this.frameTimer++;
    }

    draw(ctx, isMoving) {
        if (invulnerabilityTimer > 0 && Math.floor(frames / 5) % 2 === 0) return;

        if (this.type === 'nax') {
            let variant = NAX_VARIANTS[currentNaxIndex];
            let frame = (this.crouching) ? NAX_BASE_MATRIX.crouch : 
                        ((isMoving && Math.floor(this.frameTimer / 8) % 2 === 0) ? NAX_BASE_MATRIX.run : NAX_BASE_MATRIX.idle);
            
            let drawY = this.y;
            if(this.crouching) drawY = GROUND_Y - (frame.length * SPRITE_SCALE);

            drawNaxSprite(ctx, frame, this.x, drawY, SPRITE_SCALE, variant);

        } else {
            let variant = RUZGAR_VARIANTS[currentRuzgarIndex];
            let frame = (isMoving && Math.floor(this.frameTimer / 8) % 2 === 0) ? RUZGAR_BASE_MATRIX.run : RUZGAR_BASE_MATRIX.idle;
            drawRuzgarSprite(ctx, frame, this.x, this.y, SPRITE_SCALE, variant);
        }
    }
}

class Obstacle {
    constructor() {
        this.x = CANVAS_WIDTH;
        this.markedForDeletion = false;
        let rand = Math.random();
        
        if (rand < 0.25) this.type = 'TOWER'; 
        else if (rand < 0.5) this.type = 'HYDRANT';
        else if (rand < 0.75) this.type = 'TV';
        else this.type = 'DRONE';
        
        this.scale = 4;
        
        if (this.type === 'TOWER') {
            this.sprite = TOWER_SPRITE;
            this.y = GROUND_Y - (this.sprite.length * this.scale);
        } else if (this.type === 'HYDRANT') {
             this.sprite = HYDRANT_SPRITE;
             this.y = GROUND_Y - (this.sprite.length * this.scale);
        } else if (this.type === 'TV') {
            this.sprite = TV_SPRITE; 
            this.y = GROUND_Y - 95; 
        } else if (this.type === 'DRONE') {
            this.sprite = DRONE_SPRITE; 
            this.y = GROUND_Y - 90; 
        } else {
            this.type = 'SIGN';
            this.sprite = SIGN_SPRITE;
            this.y = GROUND_Y - 110;
        }
        
        this.w = this.sprite[0].length * this.scale;
        this.h = this.sprite.length * this.scale;
    }
    update() { this.x -= gameSpeed; if (this.x + this.w < 0) this.markedForDeletion = true; }
    draw(ctx) { drawGeneralSprite(ctx, this.sprite, this.x, this.y, this.scale, this.type); }
}

class Item {
    constructor() {
        this.x = CANVAS_WIDTH;
        // BONE is lowered for auto-collect, others are high
        this.markedForDeletion = false;
        let rand = Math.random();
        if (rand < 0.1) { 
            this.type = 'PILL'; this.sprite = PILL_SPRITE; 
            this.y = GROUND_Y - 90 - (Math.random() * 50);
        }
        else if (rand < 0.4) { 
            this.type = 'FOOD'; this.sprite = BONE_ITEM_SPRITE; 
            this.y = GROUND_Y - 30; // AUTO-COLLECT HEIGHT (Ground Level)
        }
        else { 
            this.type = 'HEADPHONE'; this.sprite = HEADPHONE_SPRITE; 
            this.y = GROUND_Y - 90 - (Math.random() * 50);
        }
        this.w = this.sprite[0].length * SPRITE_SCALE;
        this.h = this.sprite.length * SPRITE_SCALE;
    }
    update() { this.x -= gameSpeed; if (this.x + this.w < 0) this.markedForDeletion = true; }
    draw(ctx) { drawGeneralSprite(ctx, this.sprite, this.x, this.y, SPRITE_SCALE); }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.size = Math.random() * 6 + 2;
        this.speedX = Math.random() * 4 - 2; this.speedY = Math.random() * 4 - 2;
        this.color = color; this.life = 1.0;
    }
    update() { this.x += this.speedX; this.y += this.speedY; this.life -= 0.05; }
    draw(ctx) { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1.0; }
}

// --- BACKGROUND SYSTEM ---
class BackObject {
    constructor(x, type) {
        this.x = x; 
        this.type = type; 
        
        if (type === 'BUILDING') {
             this.w = 40 + Math.random() * 60; 
             this.h = 50 + Math.random() * 150;
             this.windows = []; for(let i=10; i<this.h-10; i+=20) if(Math.random()>0.3) this.windows.push(i);
             this.color = Math.random() > 0.5 ? '#1a0d26' : '#221133';
        } else {
             this.w = 8 * 6; 
             this.h = 8 * 6;
             this.yOffset = 0;
        }
    }
    draw(ctx) {
        if (this.type === 'BUILDING') {
            ctx.fillStyle = this.color; ctx.fillRect(this.x, GROUND_Y - this.h, this.w, this.h);
            ctx.fillStyle = '#3a1f52'; this.windows.forEach(wy => ctx.fillRect(this.x + 5, GROUND_Y - wy, this.w - 10, 10));
        } else {
            drawGeneralSprite(ctx, TREE_SPRITE, this.x, GROUND_Y - this.h, 6, 'TREE');
        }
    }
}
let bgObjects = []; let stars = [];

function initBackground() {
    bgObjects = []; stars = [];
    for(let i=0; i<CANVAS_WIDTH + 100; i+=80) bgObjects.push(new BackObject(i, 'BUILDING'));
    for(let i=0; i<30; i++) stars.push({x: Math.random() * CANVAS_WIDTH, y: Math.random() * (CANVAS_HEIGHT/2), size: Math.random() * 2 + 1});
    currentZone = 'CITY';
    zoneTimer = 0;
}

function updateZone() {
    zoneTimer++;
    if (zoneTimer > 1500) { 
        currentZone = currentZone === 'CITY' ? 'PARK' : 'CITY';
        zoneTimer = 0;
    }
}

// --- GAME LOGIC ---

function initGame() {
    player = new Entity(50, GROUND_Y, 'nax');
    ruzgar = new Entity(150, GROUND_Y, 'ruzgar');
    obstacles = []; items = []; particles = [];
    score = 0; hearts = 3; 
    gameSpeed = 8.0; 
    frames = 0;
    invulnerabilityTimer = 0;
    stats = { headphones: 0, food: 0, pills: 0 };
    initBackground();
}

function drawHUD(ctx) {
    const scale = 3; 
    const startX = 20; 
    const startY = 20; 
    
    // 1. Draw Hearts
    for (let i = 0; i < hearts; i++) {
        drawGeneralSprite(ctx, ICON_HEART, startX + (i * 25), startY, scale); 
    }

    // 2. Draw Stats
    const statY = startY + 30;
    let currentX = startX;

    drawGeneralSprite(ctx, ICON_BONE, currentX, statY + 5, scale);
    drawText(ctx, stats.food.toString(), currentX + 35, statY + 16, '#ffccaa');
    
    currentX += 80;
    drawGeneralSprite(ctx, ICON_HEADPHONE, currentX, statY, scale);
    drawText(ctx, stats.headphones.toString(), currentX + 35, statY + 16, '#00f3ff');
    
    currentX += 80;
    drawGeneralSprite(ctx, ICON_PILL, currentX, statY + 5, scale); 
    drawText(ctx, stats.pills.toString(), currentX + 35, statY + 16, '#ff0044');

    // 3. Score
    ctx.font = '24px VT323';
    ctx.fillStyle = '#00f3ff';
    ctx.textAlign = 'center'; // Changed from right
    ctx.fillText("DIST: " + Math.floor(score) + "m", CANVAS_WIDTH / 2, 40); // Changed x position
}

function drawText(ctx, text, x, y, color) {
    ctx.font = '24px VT323';
    ctx.fillStyle = color;
    ctx.textAlign = 'left';
    ctx.fillText(text, x, y);
}

function drawRope(ctx) {
    if (!player || !ruzgar) return;
    const naxHandX = player.x + (10 * SPRITE_SCALE); const naxHandY = player.y + (10 * SPRITE_SCALE);
    const ruzgarNeckX = ruzgar.x + (1 * SPRITE_SCALE); const ruzgarNeckY = ruzgar.y + (5 * SPRITE_SCALE);
    ctx.strokeStyle = '#aaaaaa'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(naxHandX, naxHandY);
    let midX = (naxHandX + ruzgarNeckX) / 2; let midY = (naxHandY + ruzgarNeckY) / 2 + 20; 
    ctx.quadraticCurveTo(midX, midY, ruzgarNeckX, ruzgarNeckY); ctx.stroke();
}

function spawnLogic() {
    spawnTimer--;
    if (spawnTimer <= 0) {
        if (Math.random() > 0.4) obstacles.push(new Obstacle());
        else items.push(new Item());
        
        let speedFactor = (gameSpeed / 10);
        let baseGap = 55 / speedFactor; 
        
        spawnTimer = baseGap + Math.random() * 30; 
        if(spawnTimer < 25) spawnTimer = 25; 
    }
}

function checkCollisions() {
    if (invulnerabilityTimer > 0) {
        invulnerabilityTimer--;
        return; 
    }

    let hit = false;
    for(let i=0; i<obstacles.length; i++) {
        let obs = obstacles[i];
        if(obs.markedForDeletion) continue;

        const pad = 8; 

        if(ruzgar.x < obs.x+obs.w-pad && ruzgar.x+ruzgar.w > obs.x+pad && ruzgar.y < obs.y+obs.h-pad && ruzgar.y+ruzgar.h > obs.y+pad) {
            hit = true; createParticles(ruzgar.x, ruzgar.y, '#ff0000');
        }
        if(!hit && player.x < obs.x+obs.w-pad && player.x+player.w > obs.x+pad && player.y < obs.y+obs.h-pad && player.y+player.h > obs.y+pad) {
            hit = true; createParticles(player.x, player.y, '#ff0000');
        }

        if(hit) {
            Audio.hit(); 
            hearts--; 
            invulnerabilityTimer = 60; 
            damageShake = 15; 
            Audio.bark(); 
            ruzgar.dy = -5; 
            if(hearts <= 0) gameOver();
            break; 
        }
    }

    items.forEach(item => {
        if(item.markedForDeletion) return;

        let ruzgarHit = (ruzgar.x < item.x+item.w && ruzgar.x+ruzgar.w > item.x && ruzgar.y < item.y+item.h && ruzgar.y+ruzgar.h > item.y);
        let playerHit = (player.x < item.x+item.w && player.x+player.w > item.x && player.y < item.y+item.h && player.y+player.h > item.y);
        let collected = false;

        // Auto-collect logic for bones on ground
        if (item.type === 'FOOD' && ruzgarHit) {
            collected = true;
            Audio.eat(); Audio.bark(); score += 20; stats.food++; 
            createParticles(item.x, item.y, '#ffccaa'); ruzgar.dy = -8;
        } 
        else if (item.type === 'HEADPHONE' && playerHit) {
            collected = true;
            Audio.collect(); score += 50; stats.headphones++; 
            createParticles(item.x, item.y, '#00f3ff');
        }
        else if (item.type === 'PILL' && (playerHit || ruzgarHit)) {
            collected = true;
            Audio.lifeUp(); hearts++; stats.pills++; 
            createParticles(item.x, item.y, '#ff0044');
        }

        if (collected) item.markedForDeletion = true;
    });
}

function createParticles(x, y, color) { for(let i=0; i<8; i++) particles.push(new Particle(x, y, color)); }

// --- LOOPS ---

function customizationLoop() {
    if (!isMenu) return;
    ctx.imageSmoothingEnabled = false; 

    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    let cx = CANVAS_WIDTH / 2; let cy = CANVAS_HEIGHT / 2;
    let grad = ctx.createRadialGradient(cx, cy, 20, cx, cy, 300);
    grad.addColorStop(0, '#2a0033'); grad.addColorStop(1, '#000000');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.strokeStyle = '#00f3ff'; ctx.globalAlpha = 0.2; ctx.lineWidth = 1; ctx.beginPath();
    for(let i=0; i<CANVAS_WIDTH; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i,CANVAS_HEIGHT); }
    for(let i=0; i<CANVAS_HEIGHT; i+=40) { ctx.moveTo(0,i); ctx.lineTo(CANVAS_WIDTH,i); }
    ctx.stroke(); ctx.globalAlpha = 1.0;

    const PREVIEW_SCALE = 8;
    ctx.save();
    ctx.shadowBlur = 20; ctx.shadowColor = "white"; 
    
    let naxVar = NAX_VARIANTS[currentNaxIndex];
    let naxW = NAX_BASE_MATRIX.idle[0].length * PREVIEW_SCALE;
    let naxX = (CANVAS_WIDTH / 2) - naxW - 30;
    let naxY = (CANVAS_HEIGHT / 2) - 80;
    drawNaxSprite(ctx, NAX_BASE_MATRIX.idle, naxX, naxY, PREVIEW_SCALE, naxVar);

    let ruzVar = RUZGAR_VARIANTS[currentRuzgarIndex];
    let ruzX = (CANVAS_WIDTH / 2) + 30;
    let ruzY = (CANVAS_HEIGHT / 2) - 30; 
    drawRuzgarSprite(ctx, RUZGAR_BASE_MATRIX.idle, ruzX, ruzY, PREVIEW_SCALE, ruzVar);
    ctx.restore(); 

    requestAnimationFrame(customizationLoop);
}

function gameLoop() {
    if (!isRunning) return;

    ctx.save();
    if (damageShake > 0) { ctx.translate(Math.random()*10 - 5, Math.random()*10 - 5); damageShake--; }

    const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
    grad.addColorStop(0, '#0d001a'); grad.addColorStop(1, '#2a0033');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    ctx.fillStyle = '#ff0055';
    ctx.beginPath(); ctx.arc(CANVAS_WIDTH - 150, 100, 40, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ff9900';
    ctx.beginPath(); ctx.arc(CANVAS_WIDTH - 150, 100, 35, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = '#ffffff';
    stars.forEach(s => {
        s.x -= gameSpeed * 0.05; if (s.x < 0) s.x = CANVAS_WIDTH;
        ctx.globalAlpha = Math.random() * 0.5 + 0.3; ctx.fillRect(s.x, s.y, s.size, s.size);
    });
    ctx.globalAlpha = 1.0;

    bgObjects.forEach(b => { b.x -= gameSpeed * 0.2; b.draw(ctx); });
    
    if (bgObjects.length > 0 && bgObjects[bgObjects.length-1].x < CANVAS_WIDTH) {
        let type = (currentZone === 'CITY') ? 'BUILDING' : 'TREE';
        let x = bgObjects[bgObjects.length-1].x + bgObjects[bgObjects.length-1].w + (type === 'TREE' ? 100 : 10);
        bgObjects.push(new BackObject(x, type));
    }
    bgObjects = bgObjects.filter(b => b.x + b.w > -100);

    let roadColor = currentZone === 'CITY' ? '#111' : '#1a261a'; 
    let stripeColor = currentZone === 'CITY' ? '#222' : '#223322';

    ctx.fillStyle = roadColor; ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);
    ctx.fillStyle = stripeColor; ctx.fillRect(0, GROUND_Y + 5, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y - 5);
    
    let roadOffset = (frames * gameSpeed) % 80;
    ctx.fillStyle = '#555';
    for(let i=0; i<CANVAS_WIDTH + 80; i+=80) {
        ctx.fillRect(i - roadOffset, GROUND_Y + 30, 40, 4);
    }
    
    ctx.strokeStyle = currentZone === 'CITY' ? '#ff00ff' : '#00ff41'; 
    ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(CANVAS_WIDTH, GROUND_Y); ctx.stroke();

    player.update(); ruzgar.update();
    obstacles.forEach(o => o.update()); items.forEach(i => i.update()); particles.forEach(p => p.update());
    
    obstacles = obstacles.filter(o => !o.markedForDeletion);
    items = items.filter(i => !i.markedForDeletion);
    particles = particles.filter(p => p.life > 0);

    checkCollisions();
    drawRope(ctx);

    player.draw(ctx, true); ruzgar.draw(ctx, true);
    obstacles.forEach(o => o.draw(ctx)); items.forEach(i => i.draw(ctx)); particles.forEach(p => p.draw(ctx));
    
    drawHUD(ctx);

    if (gameSpeed < 22) gameSpeed += 0.002; 
    score += (gameSpeed / 10);
    
    spawnLogic();
    updateZone();

    ctx.restore();
    frames++;
    animationId = requestAnimationFrame(gameLoop);
}

// --- INPUTS ---
function handleInput(e) {
    if(!isRunning) return;
    if(["Space","ArrowUp","ArrowDown"].indexOf(e.code) > -1) e.preventDefault();
    if(e.type==='keydown' && (e.code==='Space'||e.code==='ArrowUp')) jump();
    if(e.type==='keydown' && (e.code==='ArrowDown'||e.code==='KeyS')) crouch(true);
    if(e.type==='keyup' && (e.code==='ArrowDown'||e.code==='KeyS')) crouch(false);
    
    if(e.type==='touchstart') { 
        e.preventDefault(); 
        touchStartY = e.changedTouches[0].screenY; 
    }
    if(e.type==='touchend') {
        e.preventDefault(); 
        let dy = e.changedTouches[0].screenY - touchStartY;
        if(Math.abs(dy) > 30 && dy > 0) { crouch(true); setTimeout(()=>crouch(false),800); } 
        else jump(); 
    }
}

function jump() {
    if(hearts <= 0) return;
    if(ruzgar.grounded) {
        ruzgar.dy = JUMP_FORCE; ruzgar.grounded = false; Audio.jump();
        setTimeout(() => { if(player.grounded && !player.crouching) { player.dy = JUMP_FORCE; player.grounded = false; } }, 70);
    }
}
function crouch(isDown) { if(player.grounded) { player.crouching = isDown; if(isDown) Audio.slide(); } }

window.addEventListener('keydown', handleInput);
window.addEventListener('keyup', handleInput);
window.addEventListener('touchstart', handleInput, {passive: false});
window.addEventListener('touchend', handleInput, {passive: false});

// --- FLOW ---
let typeTimeout;
function typeWriter(text, elementId, callback) {
    const el = document.getElementById(elementId); el.textContent = ''; let i = 0;
    if (typeTimeout) clearTimeout(typeTimeout);
    function type() {
        if (!isRunning) {
             if (i < text.length) { el.textContent += text.charAt(i); i++; typeTimeout = setTimeout(type, 30); }
             else { typeTimeout = setTimeout(callback, 1000); }
        }
    }
    type();
}

function startStory() {
    Audio.init(); 
    isMenu = false;
    document.getElementById('musicBtn').classList.remove('hidden-btn'); // Show in-game btn
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('customizationScreen').classList.add('hidden');
    document.getElementById('storyScreen').classList.remove('hidden');
    const line1 = "Nax felt lost.\nThe world felt loud.\n\nBut RÃ¼zgar wanted to run.";
    typeWriter(line1, 'storyText', startGame);
    if(Audio.musicOn && !Music.isPlaying) Music.start();
}

function startGame() {
    if(isRunning) return;
    document.getElementById('storyScreen').classList.add('hidden');
    isRunning = true;
    initGame();
    gameLoop();
}

function skipIntro() {
    if(typeTimeout) clearTimeout(typeTimeout);
    startGame();
}

function gameOver() {
    isRunning = false; cancelAnimationFrame(animationId);
    Music.stop();
    document.getElementById('musicBtn').classList.add('hidden-btn'); // Hide in-game btn
    document.getElementById('gameOverScreen').classList.remove('hidden');
    document.getElementById('finalScore').innerText = Math.floor(score) + "m";
    document.getElementById('endHeadphones').innerText = stats.headphones;
    document.getElementById('endFood').innerText = stats.food;
    document.getElementById('endPills').innerText = stats.pills;
}

function resetGame() {
    document.getElementById('gameOverScreen').classList.add('hidden');
    isMenu = true;
    document.getElementById('mainMenu').classList.remove('hidden');
    if(Audio.musicOn) Music.start(); // Restart music on menu return
    customizationLoop();
}

function shareStats() {
    const text = `ðŸš€ NAX.LIFE RUN WITH RÃœZGAR\n\nðŸŽ¯ Distance: ${Math.floor(score)}m\nðŸŽ§ Headphones: ${stats.headphones}\nðŸ– Snacks: ${stats.food}\nðŸ’Š Extra Lives: ${stats.pills}\n\nCan you beat the glitch?`;
    const textarea = document.createElement('textarea'); textarea.value = text; document.body.appendChild(textarea); textarea.select();
    try { document.execCommand('copy'); document.getElementById('toast').classList.add('show'); setTimeout(()=>document.getElementById('toast').classList.remove('show'), 2000); } catch (e) {}
    document.body.removeChild(textarea);
}

customizationLoop();

</script>
</body>
</html>
